<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Initial and Final Encodings</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="slidy/styles/slidy.css" />
  <script src="slidy/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Initial and Final Encodings</h1>
  <p class="author">

  </p>
</div>
<div id="introduction" class="slide section level1">
<h1>Introduction</h1>
<p>Code is Data, and Data is Code</p>
<p>Changing how you represent your data or your program can yield practical improvements.</p>
</div>
<div id="the-basic-idea" class="slide section level1">
<h1>The Basic Idea</h1>
<p>Consider the humble linked list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span>
            <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)

<span class="co">-- data [a] = [] | a : [a]</span></code></pre></div>
<ul>
<li>Start at the head</li>
<li>Do something on each element in order</li>
</ul>
</div>
<div id="the-basic-idea-1" class="slide section level1">
<h1>The Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
[]     <span class="fu">++</span> bs <span class="fu">=</span> bs
(a<span class="fu">:</span>as) <span class="fu">++</span> bs <span class="fu">=</span> a <span class="fu">:</span> (as <span class="fu">++</span> bs)

<span class="co">-- call `:` once per element of the first list, every time you call `++`!</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">++</span> b <span class="fu">++</span> c         <span class="co">-- traverses `a` twice, `b` once</span></code></pre></div>
</div>
<div id="the-basic-idea-2" class="slide section level1">
<h1>The Basic Idea</h1>
<p>What if we turned the list inside-out?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DList</span> <span class="fu">=</span> <span class="dt">DList</span> {<span class="ot"> runDList ::</span> [a] <span class="ot">-&gt;</span> [a] }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toDList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a
toDList lst <span class="fu">=</span> <span class="dt">DList</span> (lst <span class="fu">++</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromDList ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]
fromDList (<span class="dt">DList</span> f) <span class="fu">=</span> f []</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a
cons x (<span class="dt">DList</span> xs) <span class="fu">=</span> <span class="dt">DList</span> <span class="fu">$</span> (x <span class="fu">:</span>) <span class="fu">.</span> xs

<span class="co">-- cons x (DList xs) = DList $ \g -&gt; x : (xs g)</span></code></pre></div>
</div>
<div id="the-basic-idea-3" class="slide section level1">
<h1>The Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">appendDList ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a
appendDList (<span class="dt">DList</span> xs) (<span class="dt">DList</span> ys) <span class="fu">=</span> <span class="dt">DList</span> <span class="fu">$</span> xs <span class="fu">.</span> ys
<span class="co">-- appendDList (DList xs) (DList ys) = DList $ \g -&gt; xs (ys g)</span>

<span class="co">-- call (.) once per call to `appendDList`!</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
[]     <span class="fu">++</span> bs <span class="fu">=</span> bs
(a<span class="fu">:</span>as) <span class="fu">++</span> bs <span class="fu">=</span> a <span class="fu">:</span> (as <span class="fu">++</span> bs)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- convert a series of appends back to an ordinary list</span>

(as, bs, cs) <span class="fu">=</span> (toDList a, toDList b, toDList c)

as <span class="ot">`appendDList`</span> bs <span class="ot">`appendDList`</span> cs      <span class="co">-- expand appendDList (associativity doesn&#39;t matter)</span>
<span class="dt">DList</span> <span class="fu">$</span> as <span class="fu">.</span> bs <span class="fu">.</span> cs                      <span class="co">-- rewrite each DList in terms of `toDList`</span>
<span class="dt">DList</span> <span class="fu">$</span> (a <span class="fu">++</span>) <span class="fu">.</span> (b <span class="fu">++</span>) <span class="fu">.</span> (c <span class="fu">++</span>)          <span class="co">-- run `fromDList`</span>
(a <span class="fu">++</span>) <span class="fu">.</span> (b <span class="fu">++</span>) <span class="fu">.</span> (c <span class="fu">++</span>) <span class="fu">$</span> []             <span class="co">-- apply first function</span>
(a <span class="fu">++</span>) <span class="fu">.</span> (b <span class="fu">++</span>) <span class="fu">$</span> c <span class="fu">++</span> []                 <span class="co">-- traverse `c` once when evaluating `++`</span>
(a <span class="fu">++</span>) <span class="fu">.</span> (b <span class="fu">++</span>) <span class="fu">$</span> c                       <span class="co">-- apply second function</span>
(a <span class="fu">++</span>) <span class="fu">$</span> (b <span class="fu">++</span> c)                         <span class="co">-- traverse `b` once when evaluating `++`</span>
(a <span class="fu">++</span>) <span class="fu">$</span> bc                               <span class="co">-- apply third function</span>
a <span class="fu">++</span> bc                                   <span class="co">-- traverse `a` once when evaluating `++`</span>
abc                                       <span class="co">-- concrete list in O(length abc)</span></code></pre></div>
</div>
<div id="a-less-basic-idea" class="slide section level1">
<h1>A Less Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>  <span class="co">-- so we can use &#39;forall&#39;</span>

<span class="kw">newtype</span> <span class="dt">Church</span> a <span class="fu">=</span> <span class="dt">Church</span> {
<span class="ot">  runChurch ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r)    <span class="ot">-&gt;</span> r   <span class="ot">-&gt;</span> r
               <span class="co">--          cons              nil    result</span>
  }

<span class="ot">convert ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Church</span> a
convert lst <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> foldr c n lst

<span class="ot">excommunicate ::</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> [a]
excommunicate (<span class="dt">Church</span> ch) <span class="fu">=</span> ch (<span class="fu">:</span>) []

<span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a
cons x (<span class="dt">Church</span> ch) <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span> c x <span class="fu">.</span> ch c
<span class="co">-- cons x (Church ch) = Church $ \c n -&gt; c x (ch c n)</span>

<span class="ot">appendChurch ::</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a
appendChurch (<span class="dt">Church</span> fx) (<span class="dt">Church</span> fy) <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span> fx c <span class="fu">.</span> fy c
<span class="co">-- appendChurch xs ys = Church $ \c n -&gt; runChurch xs c $ runChurch ys c n</span>

<span class="co">-- run one function composition per call to `appendChurch&#39;`!</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">                   c ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r           <span class="co">-- the folding function</span>
<span class="ot">                                   n ::</span> r     <span class="co">-- the terminating value</span></code></pre></div>
</div>
<div id="a-less-basic-idea-1" class="slide section level1">
<h1>A Less Basic Idea</h1>
<p>More general than <code>DList</code>!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)
            <span class="fu">|</span> <span class="dt">Tip</span>

<span class="kw">newtype</span> <span class="dt">Cross</span> a <span class="fu">=</span> <span class="dt">Cross</span> {
<span class="ot">    runCross ::</span> forall r<span class="fu">.</span> (r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r
    }

<span class="ot">tip ::</span> <span class="dt">Cross</span> a
tip <span class="fu">=</span> <span class="dt">Cross</span> <span class="fu">$</span> \_ t <span class="ot">-&gt;</span> t

<span class="ot">node ::</span> <span class="dt">Cross</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Cross</span> a <span class="ot">-&gt;</span> <span class="dt">Cross</span> a
node (<span class="dt">Cross</span> l) x (<span class="dt">Cross</span> r) <span class="fu">=</span> <span class="dt">Cross</span> <span class="fu">$</span> \n t <span class="ot">-&gt;</span> n (l n t) x (r n t)

<span class="ot">convertTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Cross</span> a
convertTree <span class="dt">Tip</span> <span class="fu">=</span> tip
convertTree (<span class="dt">Node</span> l x r) <span class="fu">=</span> node (convertTree l) x (convertTree r)

<span class="ot">excommunicateTree ::</span> <span class="dt">Cross</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
excommunicateTree (<span class="dt">Cross</span> x) <span class="fu">=</span> x <span class="dt">Node</span> <span class="dt">Tip</span></code></pre></div>
<p>Only the conversion need know about the ADT!</p>
</div>
<div id="a-less-basic-idea-2" class="slide section level1">
<h1>A Less Basic Idea</h1>
<p>Applies to very pragmatic problems, e.g. you don't have proper ADTs. From <code>#bfpg</code> on freenode:</p>
<blockquote>
<p>04:38:09 bkolera | It wouldn't be a big deal if we didn't encode sum types as sub types in scala, but ... &gt;_&gt;</p>
<p>04:42:56 georgew | You could just Church encode?</p>
</blockquote>
</div>
<div id="embedded-domain-specific-languages" class="slide section level1">
<h1>(Embedded) Domain-Specific Languages</h1>
<ul>
<li><p>Separate the problem domain from the software engineering</p></li>
<li><p>More accessible to domain experts than the general-purpose host language (or &quot;metalanguage&quot;)</p></li>
<li><p>Reuse the metalanguage's parser</p></li>
</ul>
</div>
<div id="the-multiple-interpretations-problem" class="slide section level1">
<h1>The Multiple Interpretations Problem</h1>
<p>Ways to interpret a program</p>
<ul>
<li>Run the program and get its result</li>
</ul>
</div>
<div id="the-multiple-interpretations-problem-1" class="slide section level1">
<h1>The Multiple Interpretations Problem</h1>
<p>Ways to interpret a program</p>
<ul>
<li><p>Run the program and get its result</p></li>
<li><p>Pretty-print or serialize the program</p></li>
<li><p>Perform optimizations before executing the program</p></li>
<li><p>Run additional checks or pre-run tests</p></li>
<li><p>Generate code</p></li>
<li><p>Execute using alternative evaluation strategies</p></li>
</ul>
</div>
<div id="the-expression-problem" class="slide section level1">
<h1>The Expression Problem</h1>
<blockquote>
<p>The Expression Problem is a new name for an old problem. The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).</p>
</blockquote>
<p>-- Philip Wadler, Nov. 1998</p>
</div>
<div id="the-static-safety-problem" class="slide section level1">
<h1>The Static Safety Problem</h1>
<p>What are the hard parts of implementing a language?</p>
<ul>
<li><p>parsers</p></li>
<li><p>code generation/evaluation</p></li>
<li><p>type checkers</p></li>
</ul>
<p>Our interpreter should let us reuse all three!</p>
</div>
<div id="solving-all-the-problems-at-once" class="slide section level1">
<h1>Solving All The Problems At Once</h1>
<p>Simply-typed lambda calculus: small but higher-order.</p>
<ul>
<li><p>ADTs</p></li>
<li><p>tagless with GADTs</p></li>
<li><p>final encoding</p></li>
<li><p>the &quot;Finally Tagless&quot; approach</p></li>
</ul>
</div>
<div id="a-simple-but-powerful-dsl" class="slide section level1">
<h1>A Simple (But Powerful) DSL</h1>
<p>STLC, with de Bruijn indices</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Simply-typed lambda calculus terms</span>
<span class="kw">data</span> <span class="dt">STLCTerm</span> <span class="fu">=</span> <span class="dt">SVar</span> <span class="dt">Var</span>
              <span class="fu">|</span> <span class="dt">SNum</span> <span class="dt">Int</span>
              <span class="fu">|</span> <span class="dt">SApp</span> <span class="dt">STLCTerm</span> <span class="dt">STLCTerm</span>
              <span class="fu">|</span> <span class="dt">SLam</span> <span class="dt">STLCTerm</span>
              <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- Representation of evaluation environments</span>
<span class="kw">data</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">VZero</span> <span class="fu">|</span> <span class="dt">VSucc</span> <span class="dt">Var</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- We need a way to look up variables in our environment.</span>
<span class="ot">lkup ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> [x] <span class="ot">-&gt;</span> x
lkup <span class="dt">VZero</span> [x] <span class="fu">=</span> x
lkup (<span class="dt">VSucc</span> v) (_<span class="fu">:</span>moar) <span class="fu">=</span> lkup v moar
lkup _ _ <span class="fu">=</span> error <span class="st">&quot;sorry, dawg; I can&#39;t interpret an open term!&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">evalSTLC env (<span class="dt">SVar</span> v) <span class="fu">=</span> lkup v env
evalSTLC env (<span class="dt">SNum</span> i) <span class="fu">=</span> i
evalSTLC env (<span class="dt">SApp</span> f x) <span class="fu">=</span> (evalSTLC env f) (evalSTLC env x)
evalSTLC env (<span class="dt">SLam</span> b) <span class="fu">=</span> \x <span class="ot">-&gt;</span> evalSTLC (x <span class="fu">:</span> env) b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">testSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SLam</span> (<span class="dt">SVar</span> <span class="dt">VZero</span>)) (<span class="dt">SNum</span> <span class="dv">22</span>)</code></pre></div>
</div>
<div id="a-simple-but-powerful-dsl-1" class="slide section level1">
<h1>A Simple (But Powerful) DSL</h1>
<p>What a puzzling error!</p>
<pre class="text"><code>[1 of 1] Compiling FinallyTagless   ( FinallyTagless.hs, interpreted )

FinallyTagless.hs:122:27:
    Couldn&#39;t match expected type ‘Int -&gt; Int’ with actual type ‘Int’
    The function ‘evalSTLC’ is applied to three arguments,
    but its type ‘[Int] -&gt; STLCTerm -&gt; Int’ has only two
    In the expression: (evalSTLC env f) (evalSTLC env x)
    In an equation for ‘evalSTLC’:
        evalSTLC env (SApp f x) = (evalSTLC env f) (evalSTLC env x)

FinallyTagless.hs:123:25:
    Couldn&#39;t match expected type ‘Int -&gt; Int’ with actual type ‘Int’
    The lambda expression ‘\ x -&gt; evalSTLC (x : env) b’
    has one argument,
    but its type ‘Int’ has none
    In the expression: \ x -&gt; evalSTLC (x : env) b
    In an equation for ‘evalSTLC’:
        evalSTLC env (SLam b) = \ x -&gt; evalSTLC (x : env) b
Failed, modules loaded: none.</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- What type do we give this?  What&#39;s the return type?</span>

evalSTLC env (<span class="dt">SVar</span> v) <span class="fu">=</span> lkup v env
evalSTLC env (<span class="dt">SNum</span> i) <span class="fu">=</span> i
evalSTLC env (<span class="dt">SApp</span> f x) <span class="fu">=</span> (evalSTLC env f) (evalSTLC env x)
evalSTLC env (<span class="dt">SLam</span> b) <span class="fu">=</span> \x <span class="ot">-&gt;</span> evalSTLC (x <span class="fu">:</span> env) b</code></pre></div>
</div>
<div id="a-less-simple-but-still-powerful-dsl" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tag</span> <span class="fu">=</span> <span class="dt">IntTag</span> <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">LambdaTag</span> (<span class="dt">Tag</span> <span class="ot">-&gt;</span> <span class="dt">Tag</span>)

<span class="ot">evalSTLC ::</span> [<span class="dt">Tag</span>] <span class="ot">-&gt;</span> <span class="dt">STLCTerm</span> <span class="ot">-&gt;</span> <span class="dt">Tag</span>
evalSTLC env (<span class="dt">SVar</span> v) <span class="fu">=</span> lkup v env
evalSTLC _   (<span class="dt">SNum</span> i) <span class="fu">=</span> <span class="dt">IntTag</span> i
evalSTLC env (<span class="dt">SApp</span> f x) <span class="fu">=</span> go (evalSTLC env f)
  <span class="kw">where</span>
    evx <span class="fu">=</span> evalSTLC env x
    go (<span class="dt">LambdaTag</span> f&#39;) <span class="fu">=</span> f&#39; evx
    go z             <span class="fu">=</span>
      error <span class="fu">$</span> <span class="st">&quot;Can&#39;t apply the non-function &#39;&quot;</span> <span class="fu">++</span> show z <span class="fu">++</span>
      <span class="st">&quot;&#39; to argument &#39;&quot;</span> <span class="fu">++</span> show evx <span class="fu">++</span> <span class="st">&quot;&#39;!&quot;</span>
evalSTLC env (<span class="dt">SLam</span> b) <span class="fu">=</span> <span class="dt">LambdaTag</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> evalSTLC (x <span class="fu">:</span> env) b

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Tag</span> <span class="kw">where</span>
  show (<span class="dt">IntTag</span> i) <span class="fu">=</span> <span class="st">&quot;&lt;&quot;</span> <span class="fu">++</span> show i <span class="fu">++</span> <span class="st">&quot; :: Int&gt;&quot;</span>
  show (<span class="dt">LambdaTag</span> _) <span class="fu">=</span> <span class="st">&quot;&lt;lambda&gt;&quot;</span>

<span class="co">-- our test program: (λx.x) 22</span>
testSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SLam</span> (<span class="dt">SVar</span> <span class="dt">VZero</span>)) (<span class="dt">SNum</span> <span class="dv">22</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> testSTLC
<span class="dt">SApp</span> (<span class="dt">SLam</span> (<span class="dt">SVar</span> <span class="dt">VZero</span>)) (<span class="dt">SNum</span> <span class="dv">22</span>)
<span class="fu">&gt;</span> evalSTLC [] testSTLC
<span class="fu">&lt;</span><span class="dv">22</span><span class="ot"> ::</span> <span class="dt">Int</span><span class="fu">&gt;</span></code></pre></div>
</div>
<div id="a-less-simple-but-still-powerful-dsl-1" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<ul>
<li>The interpreter is partial!</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SNum</span> <span class="dv">22</span>) (<span class="dt">SNum</span> <span class="dv">33</span>)

<span class="fu">&gt;</span> evalSTLC [] failSTLC
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Can&#39;t</span> apply the non<span class="fu">-</span>function <span class="ch">&#39;&lt;22 :: Int&gt;&#39;</span> to argument <span class="ch">&#39;&lt;33 :: Int&gt;&#39;</span><span class="fu">!</span></code></pre></div>
</div>
<div id="a-less-simple-but-still-powerful-dsl-2" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<ul>
<li>The interpreter is partial!</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SNum</span> <span class="dv">22</span>) (<span class="dt">SNum</span> <span class="dv">33</span>)

<span class="fu">&gt;</span> evalSTLC [] failSTLC
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Can&#39;t</span> apply the non<span class="fu">-</span>function <span class="ch">&#39;&lt;22 :: Int&gt;&#39;</span> to argument <span class="ch">&#39;&lt;33 :: Int&gt;&#39;</span><span class="fu">!</span></code></pre></div>
<ul>
<li><p>Code is more complicated</p></li>
<li><p>We have some runtime overhead due to pattern-matching on the tag</p></li>
</ul>
</div>
<div id="a-less-simple-but-still-powerful-dsl-3" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<table>
<thead>
<tr class="header">
<th align="right">Property</th>
<th align="left">Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Multiple Interpretations</td>
<td align="left">:)</td>
</tr>
<tr class="even">
<td align="right">Expression Problem</td>
<td align="left">:(</td>
</tr>
<tr class="odd">
<td align="right">Static Safety</td>
<td align="left">:(</td>
</tr>
</tbody>
</table>
</div>
<div id="a-tagless-encoding" class="slide section level1">
<h1>A Tagless Encoding</h1>
<p>Let's tackle the Static Safety Problem by using Generalised Algebraic Data Types (GADTs).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Term</span> t <span class="kw">where</span>
  <span class="co">-- This quantified type could be a particular type like `Int`, but</span>
  <span class="co">-- I&#39;m using anything I can `show` just to make interactive</span>
  <span class="co">-- debugging easier</span>
  <span class="dt">Const</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">Var</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Term</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> b <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">Lam</span><span class="ot"> ::</span> (<span class="dt">Term</span> b <span class="ot">-&gt;</span> <span class="dt">Term</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (b <span class="ot">-&gt;</span> a)

<span class="ot">eval ::</span> <span class="dt">Term</span> t <span class="ot">-&gt;</span> t
eval (<span class="dt">Var</span> x) <span class="fu">=</span> x
eval (<span class="dt">Const</span> x) <span class="fu">=</span> x
eval (<span class="dt">App</span> f x) <span class="fu">=</span> eval f (eval x)
eval (<span class="dt">Lam</span> f) <span class="fu">=</span> eval <span class="fu">.</span> f <span class="fu">.</span> <span class="dt">Var</span></code></pre></div>
<p>Let's try some test programs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">first <span class="fu">=</span> <span class="dt">Lam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">Lam</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> x

twice <span class="fu">=</span> <span class="dt">Lam</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">Lam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">Lam</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`App`</span> (f <span class="ot">`App`</span> x <span class="ot">`App`</span> y) <span class="ot">`App`</span> y

pairs <span class="fu">=</span> twice <span class="ot">`App`</span> first <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">33</span>) <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">22</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> eval pairs
<span class="dv">33</span>

<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
<span class="ot">pairs ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a</code></pre></div>
</div>
<div id="a-tagless-encoding-1" class="slide section level1">
<h1>A Tagless Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failure <span class="fu">=</span> twice <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">33</span>) <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">22</span>) <span class="ot">`App`</span> first</code></pre></div>
<pre class="text"><code>FinallyTagless.hs:210:1:
    Could not deduce (Num (a -&gt; (a0 -&gt; b0 -&gt; a0) -&gt; a))
    from the context (Num a,
                      Num (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a),
                      Show a,
                      Show (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a))
      bound by the inferred type for ‘failure’:
                 (Num a, Num (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a), Show a,
                  Show (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a)) =&gt;
                 Term a
      at FinallyTagless.hs:210:1-61
    The type variables ‘b0’, ‘a0’ are ambiguous
    When checking that ‘failure’ has the inferred type
      failure :: forall a b a1.
                 (Num a, Num (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a), Show a,
                  Show (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a)) =&gt;
                 Term a
    Probable cause: the inferred type is ambiguous</code></pre>
</div>
<div id="a-tagless-encoding-2" class="slide section level1">
<h1>A Tagless Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Users want Turing-completeness.  Management has demanded we add a</span>
<span class="co">-- fixpoint combinator without breaking any existing code!</span>

<span class="kw">data</span> <span class="dt">TermY</span> t <span class="kw">where</span>
  <span class="dt">ConstY</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TermY</span> a
  <span class="dt">VarY</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">TermY</span> a
  <span class="dt">AppY</span><span class="ot"> ::</span> <span class="dt">TermY</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">TermY</span> b <span class="ot">-&gt;</span> <span class="dt">TermY</span> a
  <span class="dt">LamY</span><span class="ot"> ::</span> (<span class="dt">TermY</span> b <span class="ot">-&gt;</span> <span class="dt">TermY</span> a) <span class="ot">-&gt;</span> <span class="dt">TermY</span> (b <span class="ot">-&gt;</span> a)
  <span class="dt">Y</span><span class="ot">    ::</span> <span class="dt">TermY</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">TermY</span> a

<span class="ot">evalY ::</span> <span class="dt">TermY</span> t <span class="ot">-&gt;</span> t
evalY (<span class="dt">VarY</span> x) <span class="fu">=</span> x
evalY (<span class="dt">ConstY</span> x) <span class="fu">=</span> x
evalY (<span class="dt">AppY</span> f x) <span class="fu">=</span> evalY f (evalY x)
evalY (<span class="dt">LamY</span> f) <span class="fu">=</span> evalY <span class="fu">.</span> f <span class="fu">.</span> <span class="dt">VarY</span>
evalY (<span class="dt">Y</span> f) <span class="fu">=</span> y&#39; <span class="fu">$</span> evalY f
  <span class="kw">where</span>
    y&#39; g <span class="fu">=</span> g <span class="fu">$</span> y&#39; g

twiceY <span class="fu">=</span> <span class="dt">LamY</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">LamY</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">LamY</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`AppY`</span> (f <span class="ot">`AppY`</span> x <span class="ot">`AppY`</span> y) <span class="ot">`AppY`</span> y</code></pre></div>
</div>
<div id="a-tagless-encoding-3" class="slide section level1">
<h1>A Tagless Encoding</h1>
<table>
<thead>
<tr class="header">
<th align="right">Property</th>
<th align="left">Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Multiple Interpretations</td>
<td align="left">:)</td>
</tr>
<tr class="even">
<td align="right">Expression Problem</td>
<td align="left">:(</td>
</tr>
<tr class="odd">
<td align="right">Static Safety</td>
<td align="left">:)</td>
</tr>
</tbody>
</table>
</div>
<div id="a-final-encoding" class="slide section level1">
<h1>A Final Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eval</span> {<span class="ot"> eval ::</span> a }

<span class="ot">var ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
var <span class="fu">=</span> <span class="dt">Eval</span>

<span class="ot">app ::</span> <span class="dt">Eval</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eval</span> b <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
app (<span class="dt">Eval</span> f) (<span class="dt">Eval</span> x) <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> f x

<span class="ot">lam ::</span> (<span class="dt">Eval</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> b) <span class="ot">-&gt;</span> <span class="dt">Eval</span> (a <span class="ot">-&gt;</span> b)
lam b <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> eval (b (<span class="dt">Eval</span> x))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- first = Lam $ \x -&gt; Lam $ \y -&gt; x</span>
first <span class="fu">=</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> x

<span class="co">-- twice = Lam $ \f -&gt; Lam $ \x -&gt; Lam $ \y -&gt; f `App` (f `App` x `App` y) `App` y</span>
twice <span class="fu">=</span> lam <span class="fu">$</span> \f <span class="ot">-&gt;</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`app`</span> (f <span class="ot">`app`</span> x <span class="ot">`app`</span> y) <span class="ot">`app`</span> y

<span class="co">-- pairs = twice `App` first `App` (Const 33) `App` (Const 22)</span>
pairs <span class="fu">=</span> twice <span class="ot">`app`</span> first <span class="ot">`app`</span> var <span class="dv">33</span> <span class="ot">`app`</span> var <span class="dv">22</span>

<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
<span class="ot">pairs ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Eval</span> a

<span class="fu">&gt;</span> eval pairs
<span class="dv">33</span></code></pre></div>
</div>
<div id="a-final-encoding-1" class="slide section level1">
<h1>A Final Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failure <span class="fu">=</span> twice <span class="ot">`app`</span> (var <span class="dv">33</span>) <span class="ot">`app`</span> (var <span class="dv">22</span>) <span class="ot">`app`</span> first

FinallyTagless.hs<span class="fu">:</span><span class="dv">72</span><span class="fu">:</span><span class="dv">5</span><span class="fu">:</span>
    <span class="dt">Non</span> <span class="kw">type</span><span class="fu">-</span>variable argument
      <span class="kw">in</span> the constraint<span class="fu">:</span> <span class="dt">Num</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a)
    (<span class="dt">Use</span> <span class="dt">FlexibleContexts</span> to permit this)
    <span class="dt">When</span> checking that ‘failure’ has the inferred <span class="kw">type</span>
<span class="ot">      failure ::</span> forall a a1 b<span class="fu">.</span>
                 (<span class="dt">Num</span> a, <span class="dt">Num</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a1 <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a), <span class="dt">Show</span> a,
                  <span class="dt">Show</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a1 <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a)) <span class="ot">=&gt;</span>
                 <span class="dt">Eval</span> a</code></pre></div>
</div>
<div id="a-final-encoding-2" class="slide section level1">
<h1>A Final Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span>Final.hs (<span class="dt">Eval</span>(..), lam, app, var)

<span class="ot">y ::</span> <span class="dt">Eval</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
y (<span class="dt">Eval</span> f) <span class="fu">=</span> <span class="dt">Eval</span> (y&#39; f)
  <span class="kw">where</span>
    y&#39; g <span class="fu">=</span> g <span class="fu">$</span> y&#39; g

twentytwo <span class="fu">=</span> y <span class="fu">$</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> const (var <span class="dv">22</span>) x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> eval <span class="fu">$</span> twentytwo
<span class="dv">22</span></code></pre></div>
</div>
<div id="a-final-encoding-3" class="slide section level1">
<h1>A Final Encoding</h1>
<table>
<thead>
<tr class="header">
<th align="right">Property</th>
<th align="left">Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Multiple Interpretations</td>
<td align="left">:(</td>
</tr>
<tr class="even">
<td align="right">Expression Problem</td>
<td align="left">:)</td>
</tr>
<tr class="odd">
<td align="right">Static Safety</td>
<td align="left">:)</td>
</tr>
</tbody>
</table>
</div>
<div id="the-finally-tagless-solution" class="slide section level1">
<h1>The Finally Tagless Solution</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FinalTerm</span> repr <span class="kw">where</span>
<span class="ot">  var ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> repr a
<span class="ot">  app ::</span> repr (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> repr b <span class="ot">-&gt;</span> repr a
<span class="ot">  lam ::</span> (repr a <span class="ot">-&gt;</span> repr b) <span class="ot">-&gt;</span> repr (a <span class="ot">-&gt;</span> b)</code></pre></div>
<p>Now we can make an instance for evaluation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eval</span> {<span class="ot"> eval ::</span> a }

<span class="kw">instance</span> <span class="dt">FinalTerm</span> <span class="dt">Eval</span> <span class="kw">where</span>
  var x <span class="fu">=</span> <span class="dt">Eval</span> x
  app (<span class="dt">Eval</span> f) (<span class="dt">Eval</span> x) <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> f x
  lam b <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> eval&#39; (b (<span class="dt">Eval</span> x))</code></pre></div>
<p>Our test programs are unchanged.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">first <span class="fu">=</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> x

twice <span class="fu">=</span> lam <span class="fu">$</span> \f <span class="ot">-&gt;</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`app`</span> (f <span class="ot">`app`</span> x <span class="ot">`app`</span> y) <span class="ot">`app`</span> y

pairs <span class="fu">=</span> twice <span class="ot">`app`</span> first <span class="ot">`app`</span> var <span class="dv">33</span> <span class="ot">`app`</span> var <span class="dv">22</span>

<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
<span class="ot">pairs ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a, <span class="dt">FinalTerm</span> repr) <span class="ot">=&gt;</span> repr a

<span class="fu">&gt;</span> eval pairs
<span class="dv">33</span></code></pre></div>
</div>
<div id="the-finally-tagless-solution-1" class="slide section level1">
<h1>The Finally Tagless Solution</h1>
<p>Let's make a second interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This is just machinery for generating variable names</span>
<span class="ot">varnames ::</span> [<span class="dt">String</span>]
varnames <span class="fu">=</span> <span class="st">&quot;xyzwabcdefghmnpqrstu&quot;</span>

parens [] <span class="fu">=</span> <span class="st">&quot;()&quot;</span>
parens str
  <span class="fu">|</span> head str <span class="fu">==</span> <span class="ch">&#39;(&#39;</span> <span class="fu">&amp;&amp;</span> last str <span class="fu">==</span> <span class="ch">&#39;)&#39;</span> <span class="fu">=</span> str
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

<span class="co">-- Here is the new type we use to choose the instance we want.</span>
<span class="kw">newtype</span> <span class="dt">Pretty</span> a <span class="fu">=</span> <span class="dt">Pretty</span> {<span class="ot"> unPretty ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span> }

<span class="kw">instance</span> <span class="dt">FinalTerm</span> <span class="dt">Pretty</span> <span class="kw">where</span>
  var <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">.</span> const <span class="fu">.</span> show
  lam f <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">$</span> \(v<span class="fu">:</span>vs) <span class="ot">-&gt;</span> parens <span class="fu">$</span>
    <span class="st">&quot;lambda &quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;. &quot;</span> <span class="fu">++</span> unPretty (f (<span class="dt">Pretty</span> <span class="fu">$</span> const v)) vs
  app (<span class="dt">Pretty</span> f) (<span class="dt">Pretty</span> x) <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span> parens <span class="fu">$</span> f c <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> x c

<span class="ot">pretty ::</span> <span class="dt">Pretty</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
pretty expr <span class="fu">=</span> unPretty expr varnames</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> pretty&#39; pairs
<span class="st">&quot;(((lambda x. (lambda y. (lambda z. ((x ((x y) z)) z)))) (lambda x. (lambda y. x)) 33) 22)&quot;</span></code></pre></div>
</div>
<div id="the-finally-tagless-solution-2" class="slide section level1">
<h1>The Finally Tagless Solution</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span>FinallyTagless.hs (<span class="dt">FinalTerm</span>(..), <span class="dt">Eval</span>(..), <span class="dt">Pretty</span>(..), pretty)

<span class="kw">class</span> <span class="dt">FinalTermY</span> repr <span class="kw">where</span>
<span class="ot">  y ::</span> repr (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> repr a

<span class="kw">instance</span> <span class="dt">FinalTermY</span> <span class="dt">Eval</span> <span class="kw">where</span>
  y (<span class="dt">Eval</span> f) <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> y&#39; f
    <span class="kw">where</span>
      y&#39; g <span class="fu">=</span> g <span class="fu">$</span> y&#39; g

<span class="kw">instance</span> <span class="dt">FinalTermY</span> <span class="dt">Pretty</span> <span class="kw">where</span>
  y (<span class="dt">Pretty</span> f) <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">$</span> \names<span class="fu">@</span>(v<span class="fu">:</span>_) <span class="ot">-&gt;</span>
    parens <span class="fu">$</span> <span class="st">&quot;fixpoint of &quot;</span> <span class="fu">++</span> f names <span class="fu">++</span> <span class="st">&quot; with respect to &#39;&quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;&#39;&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">twentytwo <span class="fu">=</span> y <span class="fu">$</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> const (var <span class="dv">22</span>) x

<span class="fu">&gt;</span> eval twentytwo
<span class="dv">22</span>

<span class="fu">&gt;</span> pretty twentytwo
<span class="st">&quot;(fixpoint of (lambda x. 22) with respect to &#39;x&#39;)&quot;</span></code></pre></div>
</div>
<div id="the-finally-tagless-approach" class="slide section level1">
<h1>The Finally Tagless Approach</h1>
<table>
<thead>
<tr class="header">
<th align="right">Property</th>
<th align="left">Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Multiple Interpretations</td>
<td align="left">:)</td>
</tr>
<tr class="even">
<td align="right">Expression Problem</td>
<td align="left">:)</td>
</tr>
<tr class="odd">
<td align="right">Static Safety</td>
<td align="left">:)</td>
</tr>
</tbody>
</table>
</div>
<div id="equivalence-of-final-and-initial-encodings" class="slide section level1">
<h1>Equivalence Of Final and Initial Encodings</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HTerm</span> h t <span class="kw">where</span>
  <span class="dt">HVar</span><span class="ot"> ::</span> <span class="dt">Show</span> t <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h t
  <span class="dt">HCell</span><span class="ot"> ::</span> h t <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h t
  <span class="dt">HApp</span><span class="ot"> ::</span> <span class="dt">HTerm</span> h (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h a <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h b
  <span class="dt">HLam</span><span class="ot"> ::</span> (<span class="dt">HTerm</span> h a <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h b) <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h (a <span class="ot">-&gt;</span> b)

<span class="co">-- An interpreter for Eval</span>
<span class="ot">evalH ::</span> <span class="dt">HTerm</span> <span class="dt">Eval</span> t <span class="ot">-&gt;</span> t
evalH (<span class="dt">HVar</span> x) <span class="fu">=</span> x
evalH (<span class="dt">HApp</span> f x) <span class="fu">=</span> evalH f (evalH x)
evalH (<span class="dt">HCell</span> x) <span class="fu">=</span> eval&#39; x
evalH (<span class="dt">HLam</span> b) <span class="fu">=</span> evalH <span class="fu">.</span> b <span class="fu">.</span> <span class="dt">HCell</span> <span class="fu">.</span> <span class="dt">Eval</span>

<span class="co">-- Now we can convert from final to initial:</span>
<span class="kw">instance</span> <span class="dt">FinalTerm</span> (<span class="dt">HTerm</span> h) <span class="kw">where</span>
  var <span class="fu">=</span> <span class="dt">HVar</span>
  app <span class="fu">=</span> <span class="dt">HApp</span>
  lam <span class="fu">=</span> <span class="dt">HLam</span>

<span class="co">-- and from initial to final:</span>
<span class="ot">convert ::</span> (<span class="dt">FinalTerm</span> repr) <span class="ot">=&gt;</span> <span class="dt">HTerm</span> repr t <span class="ot">-&gt;</span> repr t
convert (<span class="dt">HVar</span> x) <span class="fu">=</span> var x
convert (<span class="dt">HCell</span> x) <span class="fu">=</span> x
convert (<span class="dt">HApp</span> f x) <span class="fu">=</span> app (convert f) (convert x)
convert (<span class="dt">HLam</span> b) <span class="fu">=</span> lam <span class="fu">$</span> convert <span class="fu">.</span> b <span class="fu">.</span> <span class="dt">HCell</span></code></pre></div>
</div>
<div id="drawbacks" class="slide section level1">
<h1>Drawbacks</h1>
<p>There are some disadvantages . . .</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runAndPrettyPrint prog <span class="fu">=</span> (eval prog, pretty prog)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">FinallyTagless.hs<span class="fu">:</span><span class="dv">402</span><span class="fu">:</span><span class="dv">42</span><span class="fu">:</span>
    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘<span class="dt">Pretty</span> a0’ with actual <span class="kw">type</span> ‘<span class="dt">Eval</span> t’
    <span class="dt">Relevant</span> bindings include
<span class="ot">      t ::</span> <span class="dt">Eval</span> t (bound at FinallyTagless.hs<span class="fu">:</span><span class="dv">402</span><span class="fu">:</span><span class="dv">20</span>)
<span class="ot">      runAndPrettyPrint&#39; ::</span> <span class="dt">Eval</span> t <span class="ot">-&gt;</span> (t, <span class="dt">String</span>)
        (bound at FinallyTagless.hs<span class="fu">:</span><span class="dv">402</span><span class="fu">:</span><span class="dv">1</span>)
    <span class="dt">In</span> the first argument <span class="kw">of</span> ‘pretty&#39;’, namely ‘t’
    <span class="dt">In</span> the expression<span class="fu">:</span> pretty&#39; t</code></pre></div>
<blockquote>
<p>Polymorphism in Haskell is not first-class. -- Oleg</p>
</blockquote>
<p>When we pattern-match on the program, we constrain it to a single type. Alas!</p>
</div>
<div id="drawbacks-1" class="slide section level1">
<h1>Drawbacks</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="ot">runAndPrettyPrint ::</span> (forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> repr t) <span class="ot">-&gt;</span> (t, <span class="dt">String</span>)
runAndPrettyPrint prog <span class="fu">=</span> (eval prog, pretty prog)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runAndPrettyPrint pairs
(<span class="dv">33</span>,<span class="st">&quot;(((lambda x. (lambda y. (lambda z. ((x ((x y) z)) z)))) (lambda x. (lambda y. x)) 33) 22)</span>
<span class="st">&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runAndPrettyPrint twentytwo
<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">164</span><span class="fu">:</span><span class="dv">20</span><span class="fu">:</span>
    <span class="dt">Could</span> not deduce (<span class="dt">FinalTermY</span> repr)
      arising from a use <span class="kw">of</span> ‘twentytwo’ <span class="fu">.</span> <span class="fu">.</span> <span class="fu">.</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">Property</th>
<th align="left">Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Multiple Interpretations</td>
<td align="left">:)</td>
</tr>
<tr class="even">
<td align="right">Expression Problem</td>
<td align="left">:(</td>
</tr>
<tr class="odd">
<td align="right">Static Safety</td>
<td align="left">:)</td>
</tr>
</tbody>
</table>
</div>
<div id="drawbacks-2" class="slide section level1">
<h1>Drawbacks</h1>
<p>The only thing we can do with a finally-encoded term is to interpret it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Pair</span> repr repr&#39; t <span class="fu">=</span> <span class="dt">Pair</span> {<span class="ot"> unPair ::</span> (repr t, repr&#39; t) }

<span class="kw">instance</span> (<span class="dt">FinalTerm</span> repr, <span class="dt">FinalTerm</span> repr&#39;) <span class="ot">=&gt;</span> <span class="dt">FinalTerm</span> (<span class="dt">Pair</span> repr repr&#39;) <span class="kw">where</span>
  var x <span class="fu">=</span> <span class="dt">Pair</span> (var x, var x)
  app f x <span class="fu">=</span> <span class="kw">let</span> (f&#39;, f&#39;&#39;) <span class="fu">=</span> unPair f
                (x&#39;, x&#39;&#39;) <span class="fu">=</span> unPair x
            <span class="kw">in</span> <span class="dt">Pair</span> (app f&#39; x&#39;, app f&#39;&#39; x&#39;&#39;)
  lam b <span class="fu">=</span> <span class="dt">Pair</span> (lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> fst <span class="fu">.</span> unPair <span class="fu">.</span> b <span class="fu">$</span> <span class="dt">Pair</span> (x, undefined),
                lam <span class="fu">$</span> \z <span class="ot">-&gt;</span> snd <span class="fu">.</span> unPair <span class="fu">.</span> b <span class="fu">$</span> <span class="dt">Pair</span> (undefined, z))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runAndPrettyPrint prog <span class="fu">=</span> (eval <span class="fu">$</span> l prog, pretty <span class="fu">$</span> r prog)
  <span class="kw">where</span>
    l <span class="fu">=</span> fst <span class="fu">.</span> unPair
    r <span class="fu">=</span> snd <span class="fu">.</span> unPair</code></pre></div>
</div>
<div id="initial-advantages" class="slide section level1">
<h1>Initial Advantages</h1>
<p>Here are some advantages of the ADT method, also known as the &quot;initial&quot; encoding of the language:</p>
<ul>
<li><p>Pattern-matching</p></li>
<li><p>No extra machinery once we accept the need for language extensions</p></li>
<li><p>Naturally extends to type systems that can't be embedded</p></li>
</ul>
</div>
<div id="final-advantages" class="slide section level1">
<h1>Final Advantages</h1>
<p>Here are some advantages of the typeclass method, also known as the &quot;final&quot; encoding of the language:</p>
<ul>
<li><p>Solves the Expression Problem in Haskell 98</p></li>
<li><p>Function composition for substituting expressions</p></li>
</ul>
</div>
<div id="other-notes" class="slide section level1">
<h1>Other Notes</h1>
<ul>
<li><p>&quot;Coproducts for free&quot;: can this initial encoding solve the expression problem?</p></li>
<li><p>Finally Tagless can implement linear/affine LC.</p></li>
<li><p>De Bruijn works too.</p></li>
</ul>
</div>
<div id="conclusion" class="slide section level1">
<h1>Conclusion</h1>
<p><a href="https://peddie.github.io/encodings/encodings.html">Slides</a> and <a href="https://peddie.github.io/encodings/encodings-text.html">annotated slides</a> can be found at</p>
<pre><code>https://peddie.github.io/encodings</code></pre>
<p>Finally Tagless can be found at</p>
<pre><code>http://okmij.org/ftp/tagless-final/JFP.pdf</code></pre>
<p>The (very helpful) course notes can be found at</p>
<pre><code>http://okmij.org/ftp/tagless-final/course</code></pre>
<p>Wikipedia has articles on</p>
<ul>
<li>GADTs</li>
<li>Church encodings</li>
<li>Scott encodings</li>
</ul>
</div>
<div id="backups" class="slide section level1">
<h1>Backups</h1>
</div>
<div id="de-bruijn-indices-finally-encoded" class="slide section level1">
<h1>De Bruijn Indices, Finally Encoded</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FinalDBTerm</span> repr <span class="kw">where</span>
<span class="ot">  dbvar ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> repr env a
<span class="ot">  dbapp ::</span> repr env (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> repr env a <span class="ot">-&gt;</span> repr env b
  <span class="co">-- The type of &#39;dblam&#39; is pretty different from the type of the HOAS</span>
  <span class="co">-- method &#39;lam&#39;.  If you think about how &#39;EvalEnv&#39; is defined, it</span>
  <span class="co">-- makes sense -- the interpreter is going to have to wrap a</span>
  <span class="co">-- function and get the argument from the environment.  In the HOAS</span>
  <span class="co">-- case, we simply make the function explicit in the type of the</span>
  <span class="co">-- method.</span>
<span class="ot">  dblam ::</span> repr (a, env) b <span class="ot">-&gt;</span> repr env (a <span class="ot">-&gt;</span> b)

  <span class="co">-- This method states that the environment contains a value of the</span>
  <span class="co">-- correct type to be applied: lambda 0</span>
<span class="ot">  zero ::</span> repr (a, env) a
  <span class="co">-- This method states that the environment is being extended with a</span>
  <span class="co">-- value of type &#39;b&#39;.</span>
<span class="ot">  succ ::</span> repr env a <span class="ot">-&gt;</span> repr (b, env) a

<span class="kw">class</span> <span class="dt">FinalDBTermArith</span> repr <span class="kw">where</span>
<span class="ot">  dbadd ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a
<span class="ot">  dbmul ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a
<span class="ot">  dbneg ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a

<span class="kw">newtype</span> <span class="dt">EvalEnv</span> env a <span class="fu">=</span> <span class="dt">EvalEnv</span> {<span class="ot"> evalEnv ::</span> env <span class="ot">-&gt;</span> a }

<span class="kw">instance</span> <span class="dt">FinalDBTerm</span> <span class="dt">EvalEnv</span> <span class="kw">where</span>
  dbvar x <span class="fu">=</span> <span class="dt">EvalEnv</span> (const x)
  dbapp (<span class="dt">EvalEnv</span> f) (<span class="dt">EvalEnv</span> x) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> (f env) (x env)
  dblam (<span class="dt">EvalEnv</span> body) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env x <span class="ot">-&gt;</span> body (x, env)

  zero <span class="fu">=</span> <span class="dt">EvalEnv</span> fst
  succ (<span class="dt">EvalEnv</span> v) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> v <span class="fu">.</span> snd

<span class="kw">instance</span> <span class="dt">FinalDBTermArith</span> <span class="dt">EvalEnv</span> <span class="kw">where</span>
  dbadd (<span class="dt">EvalEnv</span> a) (<span class="dt">EvalEnv</span> b) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="fu">+</span> b env
  dbmul (<span class="dt">EvalEnv</span> a) (<span class="dt">EvalEnv</span> b) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="fu">*</span> b env
  dbneg (<span class="dt">EvalEnv</span> a) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> negate <span class="fu">$</span> a env

dbeval expr <span class="fu">=</span> evalEnv expr ()

dbtest&#39; <span class="fu">=</span> dblam (dbadd (succ zero) (succ (succ zero)))

dbtest&#39;&#39; <span class="fu">=</span> ((dblam (dblam dbtest&#39;) <span class="ot">`dbapp`</span> dbvar <span class="dv">22</span>) <span class="ot">`dbapp`</span> dbvar (<span class="dv">33</span><span class="ot"> ::</span> <span class="dt">Double</span>)) <span class="ot">`dbapp`</span> undefined

dbtest <span class="fu">=</span> dblam (dbadd zero zero) <span class="ot">`dbapp`</span> dbvar (<span class="dv">22</span><span class="ot"> ::</span> <span class="dt">Double</span>)</code></pre></div>
</div>
<div id="de-bruijn-indices-initially-encoded" class="slide section level1">
<h1>De Bruijn Indices, Initially Encoded</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DBVar</span> env t <span class="kw">where</span>
  <span class="dt">DBZ</span><span class="ot"> ::</span> <span class="dt">DBVar</span> (t, env) t
  <span class="dt">DBS</span><span class="ot"> ::</span> <span class="dt">DBVar</span> env t <span class="ot">-&gt;</span> <span class="dt">DBVar</span> (a, env) t

<span class="kw">data</span> <span class="dt">DBTerm</span> env t <span class="kw">where</span>
  <span class="dt">DBConst</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env t
  <span class="dt">DBVar</span><span class="ot"> ::</span> <span class="dt">DBVar</span> env t <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env t
  <span class="dt">DBLam</span><span class="ot"> ::</span> <span class="dt">DBTerm</span> (a, env) b <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env (a <span class="ot">-&gt;</span> b)
  <span class="dt">DBApp</span><span class="ot"> ::</span> <span class="dt">DBTerm</span> env (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env a <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env b

<span class="ot">dbLookup ::</span> <span class="dt">DBVar</span> env t <span class="ot">-&gt;</span> env <span class="ot">-&gt;</span> t
dbLookup  <span class="dt">DBZ</span>    (x, _)   <span class="fu">=</span> x
dbLookup (<span class="dt">DBS</span> v) (_, env) <span class="fu">=</span> dbLookup v env

<span class="ot">dbEval ::</span> env <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env t <span class="ot">-&gt;</span> t
dbEval env (<span class="dt">DBVar</span> v) <span class="fu">=</span> dbLookup v env
dbEval env (<span class="dt">DBConst</span> t) <span class="fu">=</span> t
dbEval env (<span class="dt">DBLam</span> body) <span class="fu">=</span> \x <span class="ot">-&gt;</span> dbEval (x, env) body
dbEval env (<span class="dt">DBApp</span> f arg) <span class="fu">=</span> (dbEval env f) (dbEval env arg)

dbinitialtest <span class="fu">=</span> <span class="dt">DBApp</span> (<span class="dt">DBLam</span> (<span class="dt">DBVar</span> <span class="dt">DBZ</span>)) (<span class="dt">DBConst</span> <span class="dv">22</span>)</code></pre></div>
</div>
<div id="de-bruijn-index-to-hoas-conversion" class="slide section level1">
<h1>De Bruijn Index to HOAS Conversion</h1>
<p>For this final trick, I don't think there's a way to get away without either multi-parameter type classes with functional dependencies or type families. Our environment needs to have the same tuple structure, but all the types need to change from e.g. <code>a</code> to <code>repr a</code> (though the empty environment is still simply <code>()</code>). We don't have a general way to express this with Haskell 98. Type families (or MPTCs + fundeps) let us write type-level functions to explain to the type checker the appropriate relationships between the types in the environment.</p>
<p>Note that the conversion remains open! We could add new De Bruijn-based classes and new HOAS-based counterparts in a new module, along with the translation instances, and reuse this original <code>toHOAS</code> function!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Env</span> repr a <span class="kw">where</span>
  <span class="dt">Env</span> repr () <span class="fu">=</span> ()
  <span class="dt">Env</span> repr (a, env) <span class="fu">=</span> (repr a, <span class="dt">Env</span> repr env)

<span class="kw">newtype</span> <span class="dt">WrapHOAS</span> repr env a <span class="fu">=</span> <span class="dt">WrapHOAS</span> {<span class="ot"> unwrapHOAS ::</span> <span class="dt">Env</span> repr env <span class="ot">-&gt;</span> repr a }

<span class="kw">instance</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> <span class="dt">FinalDBTerm</span> (<span class="dt">WrapHOAS</span> repr) <span class="kw">where</span>
  dbvar x <span class="fu">=</span> <span class="dt">WrapHOAS</span> (const <span class="fu">$</span> var x)
  dbapp (<span class="dt">WrapHOAS</span> f) (<span class="dt">WrapHOAS</span> x) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> app (f env) (x env)
  dblam (<span class="dt">WrapHOAS</span> body) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> body (x, env)

  zero <span class="fu">=</span> <span class="dt">WrapHOAS</span> fst
  succ (<span class="dt">WrapHOAS</span> v) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> v <span class="fu">.</span> snd

<span class="kw">instance</span> <span class="dt">FinalTermArith</span> repr <span class="ot">=&gt;</span> <span class="dt">FinalDBTermArith</span> (<span class="dt">WrapHOAS</span> repr) <span class="kw">where</span>
  dbadd (<span class="dt">WrapHOAS</span> a) (<span class="dt">WrapHOAS</span> b) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="ot">`add`</span> b env
  dbmul (<span class="dt">WrapHOAS</span> a) (<span class="dt">WrapHOAS</span> b) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="ot">`mul`</span> b env
  dbneg (<span class="dt">WrapHOAS</span> a)              <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> neg <span class="fu">$</span> a env

<span class="ot">toHOAS ::</span> <span class="dt">WrapHOAS</span> repr () a <span class="ot">-&gt;</span> repr a
toHOAS expr <span class="fu">=</span> unwrapHOAS expr ()</code></pre></div>
</div>
<div id="scott-encodings" class="slide section level1">
<h1>Scott Encodings</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="kw">newtype</span> <span class="dt">SList</span> a <span class="fu">=</span> <span class="dt">SL</span> {<span class="ot"> elim ::</span> forall b<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">SList</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b }

<span class="ot">snil ::</span> forall a<span class="fu">.</span> <span class="dt">SList</span> a
snil <span class="fu">=</span> <span class="dt">SL</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> n

<span class="ot">scons ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> <span class="dt">SList</span> a <span class="ot">-&gt;</span> <span class="dt">SList</span> a
scons x xs <span class="fu">=</span> <span class="dt">SL</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> c x xs

<span class="ot">smap ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">SList</span> a <span class="ot">-&gt;</span> <span class="dt">SList</span> b
smap f lst <span class="fu">=</span> elim lst (\x xs <span class="ot">-&gt;</span> f x <span class="ot">`scons`</span> smap f xs) snil</code></pre></div>
</div>
<div id="drawbacks-3" class="slide section level1">
<h1>Drawbacks</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE ImpredicativeTypes #-}</span>

<span class="kw">newtype</span> <span class="dt">Program</span> a <span class="fu">=</span> <span class="dt">Program</span> {
<span class="ot">  getProgram ::</span> forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> repr a
  }

<span class="ot">convert&#39; ::</span> <span class="dt">HTerm</span> (forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt; repr ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) t
         <span class="ot">-&gt;</span> (forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> repr t)
convert&#39; (<span class="dt">HVar</span> x) <span class="fu">=</span> var x
convert&#39; (<span class="dt">HCell</span> x) <span class="fu">=</span> x
convert&#39; (<span class="dt">HApp</span> f x) <span class="fu">=</span> app (convert&#39; f) (convert&#39; x)
convert&#39; (<span class="dt">HLam</span> b) <span class="fu">=</span> lam <span class="fu">$</span> convert&#39; <span class="fu">.</span> b <span class="fu">.</span> <span class="dt">HCell</span></code></pre></div>
<p>If we used the ImpredicativeTypes extension, which lets us write things like this, we could solve the problem. Sadly, GHC would no longer be able to infer types for such values. That's a heavy price to pay!</p>
</div>
<div id="codensity-transformation" class="slide section level1">
<h1>Codensity Transformation</h1>
<p>See &quot;Asymptotic Improvement of Computations Over Free Monads&quot; and &quot;Free Monads For Less&quot;.</p>
<p>http://www.iai.uni-bonn.de/~jv/mpc08.pdf</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">

<span class="kw">newtype</span> <span class="dt">Codensity</span> f a <span class="fu">=</span> <span class="dt">Codensity</span> (forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> f r) <span class="ot">-&gt;</span> f r)</code></pre></div>
</div>
<div id="optimization-example" class="slide section level1">
<h1>Optimization example?</h1>
</div>
<div id="tdpe" class="slide section level1">
<h1>TDPE?</h1>
</div>
</body>
</html>
